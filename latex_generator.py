#!/usr/bin/env python3
"""
G√©n√©rateur LaTeX EXHAUSTIF - Version ManualMiner
Utilise TOUTES les donn√©es extraites par Gemini avec branding ManualMiner
"""

import os
import json
import subprocess
import tempfile
import shutil
from pathlib import Path
from datetime import datetime
from typing import Dict, List
import logging

logger = logging.getLogger(__name__)

class LatexSynthesisGenerator:
    """G√©n√©rateur LaTeX EXHAUSTIF - Toutes les informations m√©dicales avec branding ManualMiner"""
    
    def __init__(self):
        """Initialise avec v√©rification LaTeX optimis√©e"""
        self.verify_latex_installation()
        
    def verify_latex_installation(self):
        """V√©rifie LaTeX avec v√©rification minimale"""
        try:
            result = subprocess.run(['pdflatex', '--version'], 
                                  capture_output=True, text=True, timeout=5)
            if result.returncode != 0:
                raise RuntimeError("LaTeX install√© mais non fonctionnel")
            
            logger.info("‚úÖ LaTeX d√©tect√© et pr√™t pour ManualMiner")
            
        except FileNotFoundError:
            raise RuntimeError(
                "‚ùå ERREUR CRITIQUE: LaTeX non install√©\n"
                "Installation requise pour ManualMiner:\n"
                "- Windows: MiKTeX (https://miktex.org/download)\n"
                "- Linux: sudo apt-get install texlive-latex-base texlive-latex-extra\n"
                "- Mac: MacTeX (https://tug.org/mactex/)\n"
                "AUCUNE alternative possible pour mat√©riel m√©dical"
            )
        except subprocess.TimeoutExpired:
            raise RuntimeError("‚ùå ERREUR: LaTeX ne r√©pond pas")
        except Exception as e:
            raise RuntimeError(f"‚ùå ERREUR LaTeX: {e}")
    
    def generate_latex_synthesis(self, synthesis: Dict, output_path: Path, manual_name: str, language: str = 'fr') -> bool:
        """G√©n√®re un PDF m√©dical EXHAUSTIF avec branding ManualMiner"""
        try:
            # Validation des donn√©es
            self.validate_synthesis_data(synthesis, manual_name)
            
            # Cr√©er document LaTeX COMPLET avec branding ManualMiner
            latex_content = self.create_comprehensive_latex_document(synthesis, manual_name, language)
            
            # Compilation avec timeout g√©n√©reux
            success = self.compile_latex_comprehensive(latex_content, output_path, manual_name)
            
            if not success:
                logger.error("‚ùå √âCHEC COMPILATION LaTeX ManualMiner")
                return False
            
            # Validation finale
            if not output_path.exists() or output_path.stat().st_size < 10000:
                logger.error("‚ùå PDF ManualMiner g√©n√©r√© trop petit")
                if output_path.exists():
                    output_path.unlink()
                return False
            
            logger.info(f"‚úÖ SYNTH√àSE M√âDICALE ManualMiner PDF G√âN√âR√âE: {output_path}")
            return True
                
        except Exception as e:
            logger.error(f"‚ùå ERREUR G√âN√âRATION ManualMiner: {e}")
            if output_path.exists():
                try:
                    output_path.unlink()
                except:
                    pass
            return False
    
    def validate_synthesis_data(self, synthesis: Dict, manual_name: str):
        """Validation rapide des donn√©es"""
        if not synthesis:
            raise ValueError("‚ùå Donn√©es de synth√®se vides")
        
        if not manual_name or not manual_name.strip():
            raise ValueError("‚ùå Nom du manuel manquant")
        
        logger.info("‚úÖ Donn√©es valid√©es pour g√©n√©ration ManualMiner")
    
    def create_comprehensive_latex_document(self, synthesis: Dict, manual_name: str, language: str = 'fr') -> str:
        """Cr√©e un document LaTeX EXHAUSTIF avec TOUTES les informations m√©dicales et branding ManualMiner"""
        
        # Traductions pour les sections
        translations = {
            'fr': {
                'title_prefix': 'SYNTH√àSE M√âDICALE',
                'generated_by': 'G√©n√©r√© par',
                'executive_summary': 'R√âSUM√â EX√âCUTIF',
                'general_info': 'INFORMATIONS G√âN√âRALES',
                'procedures': 'PROC√âDURES D\'ANALYSE',
                'maintenance': 'MAINTENANCE PR√âVENTIVE',
                'daily_usage': 'GUIDE D\'UTILISATION QUOTIDIENNE',
                'technical_specs': 'SP√âCIFICATIONS TECHNIQUES',
                'security': 'PR√âCAUTIONS DE S√âCURIT√â',
                'validation': 'VALIDATION CLINIQUE',
                'troubleshooting': 'D√âPANNAGE',
                'conclusion': 'CONCLUSION'
            },
            'en': {
                'title_prefix': 'MEDICAL SYNTHESIS',
                'generated_by': 'Generated by',
                'executive_summary': 'EXECUTIVE SUMMARY',
                'general_info': 'GENERAL INFORMATION',
                'procedures': 'ANALYSIS PROCEDURES',
                'maintenance': 'PREVENTIVE MAINTENANCE',
                'daily_usage': 'DAILY USAGE GUIDE',
                'technical_specs': 'TECHNICAL SPECIFICATIONS',
                'security': 'SAFETY PRECAUTIONS',
                'validation': 'CLINICAL VALIDATION',
                'troubleshooting': 'TROUBLESHOOTING',
                'conclusion': 'CONCLUSION'
            }
        }
        
        t = translations.get(language, translations['fr'])
        
        # En-t√™te LaTeX PROFESSIONNEL pour document m√©dical ManualMiner
        latex_header = r"""
\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1.8cm]{geometry}
\usepackage[table,xcdraw]{xcolor}
\usepackage{array}
\usepackage{longtable}
\usepackage{fancyhdr}
\usepackage{enumitem}
\usepackage{multicol}
\usepackage{titlesec}

% Couleurs ManualMiner m√©dicales professionnelles
\definecolor{manualblue}{RGB}{0,100,200}
\definecolor{manualred}{RGB}{180,0,0}
\definecolor{manualgreen}{RGB}{0,120,0}
\definecolor{manualorange}{RGB}{230,120,0}
\definecolor{lightblue}{RGB}{240,248,255}
\definecolor{lightgreen}{RGB}{245,255,245}
\definecolor{lightred}{RGB}{255,245,245}
\definecolor{lightorange}{RGB}{255,250,240}

% En-t√™tes professionnels ManualMiner
\pagestyle{fancy}
\fancyhf{}
\rhead{\textcolor{manualblue}{\textbf{ManualMiner - SYNTH√àSE INSTRUMENT M√âDICAL}}}
\lhead{\textcolor{manualblue}{\small\today}}
\rfoot{\textcolor{manualblue}{\textbf{\thepage}}}
\lfoot{\textcolor{manualgreen}{\textbf{¬© Paul Archer - ManualMiner}}}

% Formatage des sections
\titleformat{\section}{\large\bfseries\color{manualblue}}{\thesection}{1em}{}
\titleformat{\subsection}{\normalsize\bfseries\color{manualgreen}}{\thesubsection}{1em}{}

\title{\textcolor{manualblue}{\Large\textbf{ManualMiner}} \\ \vspace{0.2cm} \textcolor{manualblue}{\large FICHE TECHNIQUE M√âDICALE} \\ \vspace{0.3cm} \textcolor{manualblue}{\large """ + self.escape_latex_advanced(manual_name[:70]) + r"""}}
\author{}
\date{\today}

\begin{document}
\maketitle
\thispagestyle{fancy}

% Avertissement m√©dical professionnel ManualMiner
\begin{center}
\colorbox{lightred}{\parbox{0.95\textwidth}{\centering 
\textcolor{manualred}{\textbf{DOCUMENT TECHNIQUE PROFESSIONNEL ManualMiner}} \\
Synth√®se technique automatique compl√®te - V√©rification recommand√©e avant usage \\
Respecter imp√©rativement les proc√©dures du manuel complet \\
\textbf{ManualMiner v1.0 - Paul Archer}}}
\end{center}

\vspace{0.5cm}
"""

        latex_body = ""
        
        # 1. R√©sum√© ex√©cutif COMPLET avec branding
        if synthesis.get("resume_executif"):
            latex_body += rf"""
\section*{{{t['executive_summary']}}}
\colorbox{{lightblue}}{{\parbox{{0.98\textwidth}}{{\textbf{{ManualMiner - {t['generated_by']}:}} """ + self.escape_latex_advanced(synthesis["resume_executif"]) + r"""}}}}

\vspace{0.5cm}
"""
        
        # 2. Informations g√©n√©rales D√âTAILL√âES
        if synthesis.get("informations_generales"):
            latex_body += self.generate_detailed_info_section(synthesis["informations_generales"])
        
        # 3. Proc√©dures d'analyse EXHAUSTIVES
        if synthesis.get("procedures_analyses"):
            latex_body += self.generate_exhaustive_procedures_section(synthesis["procedures_analyses"])
        
        # 4. Maintenance pr√©ventive COMPL√àTE
        if synthesis.get("maintenance_preventive"):
            latex_body += self.generate_complete_maintenance_section(synthesis["maintenance_preventive"])
        
        # 5. Guide d'utilisation quotidienne
        if synthesis.get("guide_utilisation_quotidienne"):
            latex_body += self.generate_daily_usage_section(synthesis["guide_utilisation_quotidienne"])
        
        # 6. Sp√©cifications techniques
        if synthesis.get("specifications_techniques"):
            latex_body += self.generate_technical_specs_section(synthesis["specifications_techniques"])
        
        # Pied de document m√©dical professionnel ManualMiner
        latex_footer = r"""

\vfill
\begin{center}
\colorbox{lightred}{\parbox{0.95\textwidth}{\centering
\textcolor{manualred}{\textbf{RESPONSABILIT√â TECHNIQUE PROFESSIONNELLE}} \\
L'utilisateur reste enti√®rement responsable de la validation des informations, \\
de la s√©curit√© d'utilisation et de l'interpr√©tation des donn√©es. \\
Toujours v√©rifier les proc√©dures critiques dans le manuel complet.}}
\end{center}

\vspace{0.3cm}
\begin{center}
\textcolor{manualblue}{\textbf{¬© Paul Archer - ManualMiner}} \\
\textcolor{manualblue}{\small Synth√®se automatique g√©n√©r√©e le """ + datetime.now().strftime("%d/%m/%Y √† %H:%M") + r"""}
\end{center>

\end{document}
"""
        
        return latex_header + latex_body + latex_footer
    
    # [Le reste des m√©thodes reste identique √† votre version originale, 
    # mais avec les couleurs ManualMiner et les r√©f√©rences mises √† jour]
    
    def escape_latex_advanced(self, text: str) -> str:
        """√âchappement LaTeX AVANC√â pour pr√©server toutes les informations"""
        if not isinstance(text, str):
            text = str(text)
        
        if not text.strip():
            return "Non sp√©cifi√©"
        
        # √âchappement complet pour pr√©server toutes les informations
        replacements = {
            '\\': r'\textbackslash{}',
            '&': r'\&',
            '%': r'\%',
            '$': r'\$',
            '#': r'\#',
            '_': r'\_',
            '{': r'\{',
            '}': r'\}',
            '^': r'\textasciicircum{}',
            '~': r'\textasciitilde{}',
            '¬∞': r'$^\circ$',
            '¬µ': r'$\mu$',
            '‚â§': r'$\leq$',
            '‚â•': r'$\geq$',
            '¬±': r'$\pm$',
            '‚Üí': r'$\rightarrow$',
            '‚Üê': r'$\leftarrow$',
            '‚Üî': r'$\leftrightarrow$'
        }
        
        for char, escaped in replacements.items():
            text = text.replace(char, escaped)
        
        # Nettoyer les caract√®res de contr√¥le mais pr√©server les retours √† la ligne
        import re
        text = re.sub(r'[\x00-\x08\x0b\x0c\x0e-\x1f\x7f-\x9f]', ' ', text)
        
        return text
    
    def generate_detailed_info_section(self, info: Dict) -> str:
        """Section informations g√©n√©rales EXHAUSTIVE avec branding ManualMiner"""
        section = r"""
\section*{INFORMATIONS TECHNIQUES G√âN√âRALES}

\begin{longtable}{|>{\bfseries}p{4cm}|p{11cm}|}
\hline
\rowcolor{lightblue}
\multicolumn{2}{|c|}{\textcolor{manualblue}{\textbf{IDENTIFICATION INSTRUMENT - ManualMiner}}} \\
\hline
\endfirsthead
\hline
\rowcolor{lightblue}
\multicolumn{2}{|c|}{\textcolor{manualblue}{\textbf{IDENTIFICATION INSTRUMENT (suite)}}} \\
\hline
\endhead
"""
        
        fields = {
            "nom_instrument": "Instrument",
            "fabricant": "Fabricant", 
            "modele": "Mod√®le",
            "type_instrument": "Type/Technologie",
            "principe_fonctionnement": "Principe technique",
            "approche_diagnostique": "M√©thodologie diagnostique"
        }
        
        for key, label in fields.items():
            if key in info and info[key]:
                value = str(info[key])
                section += f"{label} & {self.escape_latex_advanced(value)} \\\\\n\\hline\n"
        
        # Applications cliniques D√âTAILL√âES
        if info.get("applications_principales"):
            section += "Applications cliniques & "
            apps_list = []
            for i, app in enumerate(info["applications_principales"][:8]):
                apps_list.append(f"\\textbf{{{i+1}.}} {self.escape_latex_advanced(str(app))}")
            apps_text = " \\\\ ".join(apps_list)
            section += f"{apps_text} \\\\\n\\hline\n"
        
        section += r"""
\end{longtable}

\vspace{0.5cm}
"""
        return section
    
    # [Inclure toutes les autres m√©thodes de votre fichier original avec les ajustements de couleurs ManualMiner]
    
    def compile_latex_comprehensive(self, latex_content: str, output_path: Path, manual_name: str) -> bool:
        """Compilation LaTeX EXHAUSTIVE avec timeout g√©n√©reux et branding ManualMiner"""
        try:
            with tempfile.TemporaryDirectory() as temp_dir:
                temp_dir_path = Path(temp_dir)
                
                # Fichier LaTeX
                tex_file = temp_dir_path / "manualminer_synthesis.tex"
                with open(tex_file, 'w', encoding='utf-8') as f:
                    f.write(latex_content)
                
                logger.info(f"üìÑ Compilation LaTeX ManualMiner: {manual_name[:50]}")
                
                # Configuration optimis√©e pour document m√©dical ManualMiner
                env = dict(os.environ)
                env.update({
                    'MIKTEX_AUTOINSTALL': 'No',  
                    'MIKTEX_UPDATE_CHECK': 'No',  
                    'max_print_line': '2000',     
                    'error_line': '500',
                    'half_error_line': '100'
                })
                
                cmd = [
                    'pdflatex', 
                    '-interaction=batchmode',      
                    '-file-line-error',            
                    '-no-shell-escape',            
                    '-output-directory', str(temp_dir_path),
                    str(tex_file)
                ]
                
                logger.info("‚è±Ô∏è D√©marrage compilation ManualMiner (timeout 120s)...")
                
                # Premi√®re passe
                result1 = subprocess.run(
                    cmd,
                    capture_output=True, 
                    text=True, 
                    cwd=temp_dir_path, 
                    timeout=120,
                    env=env
                )
                
                # Deuxi√®me passe pour les r√©f√©rences crois√©es
                logger.info("Deuxi√®me passe LaTeX ManualMiner...")
                result2 = subprocess.run(
                    cmd,
                    capture_output=True, 
                    text=True, 
                    cwd=temp_dir_path, 
                    timeout=120,
                    env=env
                )
                
                # V√©rifier PDF g√©n√©r√© (priorit√© au r√©sultat)
                pdf_file = temp_dir_path / "manualminer_synthesis.pdf"
                if pdf_file.exists() and pdf_file.stat().st_size > 5000:
                    logger.info(f"PDF ManualMiner g√©n√©r√©: {pdf_file.stat().st_size:,} bytes")
                    
                    # Copie vers destination
                    shutil.copy2(pdf_file, output_path)
                    
                    if output_path.exists():
                        final_size = output_path.stat().st_size
                        logger.info(f"PDF m√©dical ManualMiner cr√©√©: {final_size:,} bytes")
                        return True
                
                # √âchec - diagnostics d√©taill√©s
                logger.error(f"Compilation √©chou√©e ManualMiner (codes {result1.returncode}, {result2.returncode})")
                
                # Diagnostics sp√©cifiques pour document exhaustif
                stderr1 = result1.stderr.lower()
                stdout1 = result1.stdout.lower()
                
                if "memory" in stderr1 or "capacity exceeded" in stderr1:
                    logger.error("Document trop volumineux pour LaTeX")
                    logger.error("   1. Le document ManualMiner est tr√®s complet, normal pour usage m√©dical")
                    logger.error("   2. Augmenter la m√©moire LaTeX si possible")
                elif "emergency stop" in stdout1 or "fatal error" in stdout1:
                    logger.error("Erreur dans le document LaTeX ManualMiner")
                    logger.error("   Document tr√®s d√©taill√©, certains caract√®res sp√©ciaux posent probl√®me")
                else:
                    logger.error("Diagnostic: Document LaTeX ManualMiner complexe")
                    logger.error(f"   STDERR: {result1.stderr[:300]}")
                
                return False
                    
        except subprocess.TimeoutExpired:
            logger.error("TIMEOUT compilation LaTeX ManualMiner (120s)")
            logger.error("Document m√©dical tr√®s complet, compilation longue normale")
            logger.error("   Solutions:")
            logger.error("   1. Le document contient beaucoup d'informations (normal)")
            logger.error("   2. Augmenter le timeout si n√©cessaire")
            return False
        except Exception as e:
            logger.error(f"ERREUR critique compilation ManualMiner: {e}")
            return False

    def generate_exhaustive_procedures_section(self, procedures: List[Dict]) -> str:
        """Section proc√©dures d'analyse EXHAUSTIVE avec toutes les informations"""
        section = r"""
\section*{PROC√âDURES D'ANALYSE M√âDICALES}

"""
        
        for i, proc in enumerate(procedures[:6]):  # Maximum 6 proc√©dures pour √©viter PDF trop long
            section += f"\\subsection*{{\\textcolor{{manualgreen}}{{{i+1}. {self.escape_latex_advanced(proc.get('nom_analyse', f'Analyse {i+1}')[:60])}}}}}\n\n"
            
            # Indication clinique
            if proc.get('indication_clinique'):
                section += f"\\textbf{{\\textcolor{{manualorange}}{{Indication clinique:}}}} {self.escape_latex_advanced(proc['indication_clinique'][:200])}\n\n"
            
            section += "\\vspace{0.3cm}\n"
            
            # Informations √©chantillon COMPL√àTES
            echantillon = proc.get('echantillon', {})
            if echantillon and isinstance(echantillon, dict):
                section += "\\textbf{\\textcolor{manualblue}{√âCHANTILLON D√âTAILL√â:}}\n"
                section += "\\begin{itemize}[leftmargin=1cm]\n"
                
                for field, label in [
                    ('type', 'Type'), ('volume_minimum', 'Volume minimum'),
                    ('volume_traitement', 'Volume traitement'), ('anticoagulant', 'Anticoagulant')
                ]:
                    if echantillon.get(field):
                        section += f"\\item \\textbf{{{label}:}} {self.escape_latex_advanced(str(echantillon[field])[:100])}\n"
                
                section += "\\end{itemize}\n\n"
            
            section += "\\vspace{0.3cm}\n"
            
            # Pr√©paration d√©taill√©e COMPL√àTE
            preparation = proc.get('preparation_detaillee', {})
            if preparation and isinstance(preparation, dict):
                if preparation.get('etapes'):
                    section += "\\textbf{\\textcolor{manualgreen}{PR√âPARATION √âCHANTILLON:}}\n"
                    section += "\\begin{enumerate}[leftmargin=1cm]\n"
                    for j, step in enumerate(preparation['etapes'][:8]):  # Max 8 √©tapes
                        section += f"\\item {self.escape_latex_advanced(str(step)[:150])}\n"
                    section += "\\end{enumerate}\n"
                
                # Conditions de stockage/stabilit√©
                if preparation.get('stabilite'):
                    section += f"\\textbf{{Stabilit√©:}} {self.escape_latex_advanced(str(preparation['stabilite'])[:200])}\n\n"
                if preparation.get('stockage'):
                    section += f"\\textbf{{Stockage:}} {self.escape_latex_advanced(str(preparation['stockage'])[:200])}\n\n"
            
            section += "\\vspace{0.3cm}\n"
            
            # Proc√©dure analytique
            procedure_ana = proc.get('procedure_analytique', {})
            if procedure_ana and isinstance(procedure_ana, dict):
                if procedure_ana.get('workflow'):
                    section += "\\textbf{\\textcolor{manualgreen}{PROC√âDURE ANALYTIQUE:}}\n"
                    section += "\\begin{enumerate}[leftmargin=1cm]\n"
                    for j, step in enumerate(procedure_ana['workflow'][:10]):  # Max 10 √©tapes
                        section += f"\\item {self.escape_latex_advanced(str(step)[:180])}\n"
                    section += "\\end{enumerate}\n"
                
                if procedure_ana.get('duree_totale'):
                    section += f"\\textbf{{Dur√©e totale:}} {self.escape_latex_advanced(str(procedure_ana['duree_totale']))}\n\n"
                if procedure_ana.get('conditions_techniques'):
                    section += f"\\textbf{{Conditions techniques:}} {self.escape_latex_advanced(str(procedure_ana['conditions_techniques'])[:200])}\n\n"
            
            section += "\\vspace{0.3cm}\n"
            
            # Performance analytique (CRITIQUE)
            performance = proc.get('performance_analytique', {})
            if performance and isinstance(performance, dict):
                section += "\\colorbox{lightorange}{\\parbox{0.98\\textwidth}{\n"
                section += "\\textbf{\\textcolor{manualorange}{PERFORMANCE ANALYTIQUE:}} \\\\\n"
                
                for field, label in [
                    ('gamme_mesure', 'Gamme mesure'), ('limite_detection', 'Limite d√©tection'),
                    ('limite_quantification', 'Limite quantification'), ('precision', 'Pr√©cision'),
                    ('sensibilite_clinique', 'Sensibilit√© clinique'), ('specificite_clinique', 'Sp√©cificit√© clinique')
                ]:
                    if performance.get(field):
                        section += f"\\textbf{{{label}:}} {self.escape_latex_advanced(str(performance[field])[:120])} \\\\\n"
                
                section += "}}\n\n"
            
            section += "\\vspace{0.3cm}\n"
            
            # Contr√¥les qualit√©
            controles = proc.get('controles_qualite', {})
            if controles and isinstance(controles, dict):
                if controles.get('types_controles'):
                    section += "\\textbf{\\textcolor{manualblue}{CONTR√îLES QUALIT√â:}}\n"
                    section += "\\begin{itemize}[leftmargin=1cm]\n"
                    for ctrl in controles['types_controles'][:6]:
                        section += f"\\item {self.escape_latex_advanced(str(ctrl)[:120])}\n"
                    if controles.get('frequence'):
                        section += f"\\item \\textbf{{Fr√©quence:}} {self.escape_latex_advanced(str(controles['frequence'])[:80])}\n"
                    section += "\\end{itemize}\n\n"
            
            section += "\\vspace{0.3cm}\n"
            
            # Pr√©cautions critiques (S√âCURIT√â)
            if proc.get('precautions_critiques'):
                section += "\\begin{center}\n"
                section += "\\colorbox{lightred}{\\parbox{0.95\\textwidth}{\n"
                section += "\\textbf{\\textcolor{manualred}{PR√âCAUTIONS CRITIQUES:}} \\\\\n"
                for j, prec in enumerate(proc['precautions_critiques'][:5]):
                    section += f"\\textbf{{{j+1}.}} {self.escape_latex_advanced(str(prec)[:150])} \\\\\n"
                section += "}}\n"
                section += "\\end{center}\n\n"
            
            section += "\\vspace{0.4cm}\n"
            
            # Saut de page apr√®s 3 proc√©dures pour lisibilit√©
            if i == 2 and len(procedures) > 3:
                section += "\\newpage\n"
        
        return section
    
    def generate_complete_maintenance_section(self, maintenance: List[Dict]) -> str:
        """Section maintenance pr√©ventive EXHAUSTIVE"""
        if not maintenance:
            return ""
        
        section = r"""
\section*{MAINTENANCE PR√âVENTIVE}

\colorbox{lightorange}{\parbox{0.98\textwidth}{
\textbf{\textcolor{manualorange}{IMPORTANCE CRITIQUE:}} La maintenance pr√©ventive est essentielle pour garantir la fiabilit√© diagnostique, la s√©curit√© des analyses et la validit√© des r√©sultats.}}

\vspace{0.3cm}

"""
        
        for i, maint in enumerate(maintenance[:8]):  # Maximum 8 maintenances
            if not isinstance(maint, dict):
                continue
                
            section += f"\\subsection*{{\\textcolor{{manualorange}}{{{i+1}. {self.escape_latex_advanced(maint.get('type_maintenance', f'Maintenance {i+1}')[:50])}}}}}\n\n"
            
            # Informations g√©n√©rales D√âTAILL√âES
            section += "\\begin{itemize}[leftmargin=1cm]\n"
            if maint.get('frequence_precise'):
                section += f"\\item \\textbf{{Fr√©quence:}} {self.escape_latex_advanced(str(maint['frequence_precise'])[:80])}\n"
            if maint.get('duree_estimee'):
                section += f"\\item \\textbf{{Dur√©e estim√©e:}} {self.escape_latex_advanced(str(maint['duree_estimee'])[:60])}\n"
            if maint.get('niveau'):
                section += f"\\item \\textbf{{Niveau:}} {self.escape_latex_advanced(str(maint.get('niveau', 'Personnel qualifi√©'))[:80])}\n"
            section += "\\end{itemize}\n\n"
            
            # Proc√©dure step-by-step COMPL√àTE
            procedure = maint.get('procedure_step_by_step', {})
            if procedure and isinstance(procedure, dict):
                if procedure.get('preparation'):
                    section += "\\textbf{\\textcolor{manualgreen}{Pr√©paration:}}\n"
                    section += "\\begin{enumerate}[leftmargin=1cm]\n"
                    for step in procedure['preparation'][:6]:
                        section += f"\\item {self.escape_latex_advanced(str(step)[:120])}\n"
                    section += "\\end{enumerate}\n\n"
                
                if procedure.get('execution'):
                    section += "\\textbf{\\textcolor{manualgreen}{Ex√©cution:}}\n"
                    section += "\\begin{enumerate}[leftmargin=1cm]\n"
                    for step in procedure['execution'][:8]:
                        section += f"\\item {self.escape_latex_advanced(str(step)[:120])}\n"
                    section += "\\end{enumerate}\n\n"
                
                if procedure.get('verification'):
                    section += "\\textbf{\\textcolor{manualblue}{V√©rifications:}}\n"
                    section += "\\begin{itemize}[leftmargin=1cm]\n"
                    for verif in procedure['verification'][:6]:
                        section += f"\\item {self.escape_latex_advanced(str(verif)[:100])}\n"
                    section += "\\end{itemize}\n\n"
            
            # Mat√©riels requis D√âTAILL√âS
            if maint.get('materiels_specifiques'):
                materials = maint['materiels_specifiques']
                if materials:
                    section += f"\\textbf{{Mat√©riels requis:}} "
                    materials_text = ', '.join([self.escape_latex_advanced(str(mat)[:60]) for mat in materials[:8]])
                    section += f"{materials_text}\n\n"
            
            section += "\\vspace{0.3cm}\n"
        
        return section
    
    def generate_daily_usage_section(self, guide: Dict) -> str:
        """Section guide d'utilisation quotidienne EXHAUSTIF"""
        section = r"""
\section*{GUIDE D'UTILISATION QUOTIDIENNE}

"""
        
        # D√©marrage syst√®me COMPLET
        if guide.get('demarrage_systeme'):
            section += "\\subsection*{\\textcolor{manualgreen}{D√©marrage syst√®me}}\n"
            section += "\\colorbox{lightgreen}{\\parbox{0.98\\textwidth}{\n"
            section += "\\begin{enumerate}[leftmargin=0.5cm]\n"
            for step in guide['demarrage_systeme'][:8]:
                section += f"\\item {self.escape_latex_advanced(str(step)[:120])}\n"
            section += "\\end{enumerate}\n"
            section += "}}\n\n"
        
        # Workflows disponibles
        if guide.get('workflow_type'):
            section += "\\subsection*{\\textcolor{manualblue}{Workflows disponibles}}\n"
            section += "\\begin{itemize}[leftmargin=1cm]\n"
            for workflow in guide['workflow_type'][:6]:
                section += f"\\item {self.escape_latex_advanced(str(workflow)[:150])}\n"
            section += "\\end{itemize}\n\n"
        
        # Arr√™t syst√®me COMPLET
        if guide.get('arret_systeme'):
            section += "\\subsection*{\\textcolor{manualorange}{Arr√™t syst√®me}}\n"
            section += "\\colorbox{lightorange}{\\parbox{0.98\\textwidth}{\n"
            section += "\\begin{enumerate}[leftmargin=0.5cm]\n"
            for step in guide['arret_systeme'][:8]:
                section += f"\\item {self.escape_latex_advanced(str(step)[:120])}\n"
            section += "\\end{enumerate}\n"
            section += "}}\n\n"
        
        # Contr√¥le qualit√© routine D√âTAILL√â
        if guide.get('controle_qualite_routine'):
            section += "\\subsection*{\\textcolor{manualblue}{Contr√¥les qualit√© routine}}\n"
            section += "\\begin{itemize}[leftmargin=1cm]\n"
            for ctrl in guide['controle_qualite_routine'][:8]:
                section += f"\\item {self.escape_latex_advanced(str(ctrl)[:120])}\n"
            section += "\\end{itemize}\n\n"
        
        # Maintenance quotidienne
        if guide.get('maintenance_quotidienne'):
            section += "\\subsection*{\\textcolor{manualgreen}{Maintenance quotidienne}}\n"
            section += "\\begin{itemize}[leftmargin=1cm]\n"
            for task in guide['maintenance_quotidienne'][:6]:
                section += f"\\item {self.escape_latex_advanced(str(task)[:100])}\n"
            section += "\\end{itemize}\n\n"
        
        return section
    
    def generate_technical_specs_section(self, specs: List[Dict]) -> str:
        """Section sp√©cifications techniques (si disponibles)"""
        if not specs:
            return ""
        
        section = r"""
\section*{SP√âCIFICATIONS TECHNIQUES}

"""
        
        for spec in specs[:4]:  # Maximum 4 cat√©gories
            if not isinstance(spec, dict):
                continue
            if spec.get('categorie') and spec.get('parametres_detailles'):
                section += f"\\subsection*{{\\textcolor{{manualblue}}{{{self.escape_latex_advanced(spec['categorie'][:50])}}}}}\n\n"
                
                section += "\\begin{longtable}{|>{\\bfseries}p{4cm}|p{5cm}|p{2cm}|p{3cm}|}\n"
                section += "\\hline\n"
                section += "\\rowcolor{lightblue}\n"
                section += "\\textcolor{manualblue}{\\textbf{PARAM√àTRE}} & \\textcolor{manualblue}{\\textbf{VALEUR}} & \\textcolor{manualblue}{\\textbf{UNIT√â}} & \\textcolor{manualblue}{\\textbf{CONDITIONS}} \\\\\n"
                section += "\\hline\n"
                
                for param in spec['parametres_detailles'][:10]:  # Max 10 param√®tres par cat√©gorie
                    if isinstance(param, dict):
                        nom = self.escape_latex_advanced(str(param.get('nom', 'Param√®tre'))[:35])
                        valeur = self.escape_latex_advanced(str(param.get('valeur', 'N/A'))[:45])
                        unite = self.escape_latex_advanced(str(param.get('unite', ''))[:15])
                        conditions = self.escape_latex_advanced(str(param.get('conditions_mesure', ''))[:30])
                        
                        section += f"{nom} & {valeur} & {unite} & {conditions} \\\\\n\\hline\n"
                
                section += "\\end{longtable}\n\n"
        
        return section


def test_latex_manualminer():
    """Test du g√©n√©rateur ManualMiner"""
    
    test_synthesis = {
        "resume_executif": "Test de g√©n√©ration PDF m√©dical ManualMiner avec toutes les informations d√©taill√©es extraites par Gemini 2.0 Flash. Ce document contient l'ensemble des proc√©dures, maintenances et sp√©cifications techniques critiques pour usage m√©dical professionnel avec le nouveau branding ManualMiner.",
        
        "informations_generales": {
            "nom_instrument": "Analyseur Test ManualMiner",
            "fabricant": "Test Medical Corp", 
            "modele": "Model-X Pro Advanced",
            "type_instrument": "Analyseur m√©dical automatis√© haute performance",
            "applications_principales": [
                "Diagnostic m√©dical de pr√©cision",
                "Analyses quantitatives en routine",
                "Contr√¥le qualit√© laboratoire",
                "Suivi th√©rapeutique patient"
            ],
            "principe_fonctionnement": "Principe technique avanc√© bas√© sur la technologie de pointe pour analyses m√©dicales de haute pr√©cision avec validation clinique compl√®te",
            "approche_diagnostique": "M√©thodologie diagnostique int√©gr√©e avec workflow optimis√© pour usage clinique quotidien"
        },
        
        "procedures_analyses": [
            {
                "nom_analyse": "Analyse Test Compl√®te ManualMiner",
                "indication_clinique": "Diagnostic et suivi m√©dical pour population cible sp√©cifique avec indications cliniques pr√©cises",
                "echantillon": {
                    "type": "√âchantillon sanguin EDTA",
                    "volume_minimum": "500 ¬µL minimum requis",
                    "volume_traitement": "200 ¬µL pour traitement",
                    "anticoagulant": "EDTA K3 recommand√©"
                },
                "preparation_detaillee": {
                    "etapes": [
                        "Pr√©l√®vement selon proc√©dure standard avec pr√©cautions aseptiques",
                        "Centrifugation √† 3000 rpm pendant 10 minutes √† temp√©rature ambiante",
                        "S√©paration du plasma avec pipetage soigneux √©vitant contamination",
                        "Stockage temporaire √† 2-8¬∞C maximum 4 heures avant analyse"
                    ],
                    "stabilite": "Stable 24h √† 2-8¬∞C, 1 semaine √† -20¬∞C, 6 mois √† -80¬∞C",
                    "stockage": "Conditions de stockage strictes selon temp√©rature et dur√©e sp√©cifi√©es"
                },
                "procedure_analytique": {
                    "workflow": [
                        "Initialisation syst√®me avec contr√¥les qualit√© obligatoires",
                        "Chargement √©chantillons selon protocole valid√©",
                        "Analyse automatis√©e avec surveillance continue param√®tres",
                        "Validation r√©sultats avec contr√¥les int√©gr√©s",
                        "G√©n√©ration rapport avec interpr√©tation technique"
                    ],
                    "duree_totale": "45 minutes par s√©rie incluant contr√¥les",
                    "conditions_techniques": "Temp√©rature 18-25¬∞C, humidit√© <60%, vibrations minimales"
                },
                "performance_analytique": {
                    "gamme_mesure": "0.1 - 1000 UI/mL avec lin√©arit√© valid√©e",
                    "limite_detection": "0.05 UI/mL (IC 95%)",
                    "precision": "CV intra-s√©rie <3%, inter-s√©rie <5%"
                },
                "controles_qualite": {
                    "types_controles": [
                        "Contr√¥le n√©gatif: <0.1 UI/mL attendu",
                        "Contr√¥le positif bas: 50¬±15 UI/mL",
                        "Contr√¥le positif haut: 500¬±50 UI/mL"
                    ],
                    "frequence": "Chaque s√©rie d'analyse, minimum quotidien"
                },
                "precautions_critiques": [
                    "S√âCURIT√â BIOLOGIQUE: Manipulation √©chantillons infectieux - EPI complet obligatoire",
                    "QUALIT√â ANALYTIQUE: Pr√©vention contamination crois√©e - nettoyage syst√®me entre s√©ries"
                ]
            }
        ],
        
        "maintenance_preventive": [
            {
                "type_maintenance": "Maintenance quotidienne ManualMiner",
                "frequence_precise": "Chaque jour d'utilisation obligatoire",
                "duree_estimee": "15-20 minutes selon complexit√©",
                "procedure_step_by_step": {
                    "preparation": [
                        "Arr√™t complet syst√®me selon proc√©dure s√©curis√©e",
                        "Pr√©paration solutions nettoyage selon concentrations",
                        "V√©rification disponibilit√© mat√©riels maintenance"
                    ],
                    "execution": [
                        "Nettoyage surfaces externes avec solution d√©sinfectante",
                        "Vidange et rin√ßage circuits fluidiques internes",
                        "Contr√¥le visuel composants critiques usure",
                        "Test fonctionnel rapide avant remise en service"
                    ],
                    "verification": [
                        "V√©rification √©tanch√©it√© circuits apr√®s nettoyage",
                        "Test alarmes et s√©curit√©s syst√®me",
                        "Validation param√®tres techniques nominaux"
                    ]
                },
                "materiels_specifiques": [
                    "Solution nettoyage sp√©cialis√©e r√©f√©rence XYZ-123",
                    "Kits consommables maintenance hebdomadaire"
                ]
            }
        ],
        
        "guide_utilisation_quotidienne": {
            "demarrage_systeme": [
                "V√©rification alimentation √©lectrique et connexions r√©seau",
                "Contr√¥le niveaux r√©actifs et consommables disponibles",
                "Test fonctionnel syst√®me avec s√©quence diagnostic",
                "Validation contr√¥les qualit√© journaliers obligatoires"
            ],
            "arret_systeme": [
                "Finalisation toutes analyses en cours avec sauvegarde",
                "Nettoyage automatique circuits selon programme",
                "Sauvegarde donn√©es et rapports journaliers",
                "Mise en s√©curit√© syst√®me pour arr√™t prolong√©"
            ],
            "maintenance_quotidienne": [
                "Contr√¥le visuel g√©n√©ral instrument et accessoires",
                "Nettoyage surfaces externes selon produits autoris√©s",
                "V√©rification niveaux et p√©remption r√©actifs",
                "Documentation observations dans registre maintenance"
            ]
        }
    }
    
    try:
        generator = LatexSynthesisGenerator()
        output_path = Path("test_manualminer.pdf")
        
        print("Test g√©n√©rateur LaTeX ManualMiner")
        print("=" * 50)
        
        success = generator.generate_latex_synthesis(
            test_synthesis, output_path, "Test M√©dical ManualMiner"
        )
        
        if success:
            print(f"SUCC√àS: PDF ManualMiner g√©n√©r√©")
            print(f"Fichier: {output_path}")
            print(f"Taille: {output_path.stat().st_size:,} bytes")
            print(f"Document complet avec branding ManualMiner")
        else:
            print("√âCHEC: G√©n√©ration impossible")
            
    except Exception as e:
        print(f"ERREUR: {e}")

if __name__ == "__main__":
    test_latex_manualminer()